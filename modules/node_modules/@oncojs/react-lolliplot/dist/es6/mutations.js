import { halfPixel } from './spatial';
import theme from './theme';

var setupMutations = function setupMutations(_ref) {
  var d3 = _ref.d3,
      scaleLinearY = _ref.scaleLinearY,
      onMutationClick = _ref.onMutationClick,
      onMutationMouseover = _ref.onMutationMouseover,
      onMutationMouseout = _ref.onMutationMouseout,
      getMutationColor = _ref.getMutationColor,
      data = _ref.data,
      yAxisOffset = _ref.yAxisOffset,
      xAxisOffset = _ref.xAxisOffset,
      height = _ref.height,
      proteinHeight = _ref.proteinHeight,
      scale = _ref.scale,
      mutationId = _ref.mutationId,
      chart = _ref.chart,
      uniqueSelector = _ref.uniqueSelector,
      animating = _ref.animating,
      min = _ref.min,
      max = _ref.max,
      width = _ref.width;

  var scaleLinear = d3.scaleLinear().domain([min, max]).range([yAxisOffset, width]);

  chart.append('g').selectAll('line').data(data.mutations).enter().append('line').attrs({
    class: function _class(d) {
      return 'mutation-line-' + d.id;
    },
    'clip-path': 'url(#' + uniqueSelector + '-chart-clip)',
    x1: function x1(d) {
      return scaleLinear(d.x);
    },
    y1: height - xAxisOffset,
    x2: function x2(d) {
      return scaleLinear(d.x);
    },
    y2: function y2(d) {
      return scaleLinearY(d.donors);
    },
    stroke: 'rgba(0, 0, 0, 0.2)'
  });

  chart.append('g').selectAll('circle').data(data.mutations).enter().append('circle').attrs({
    class: function _class(d) {
      return 'mutation-circle-' + d.id + ' ' + (d.id === mutationId ? 'selected-mutation' : '');
    },
    'clip-path': 'url(#' + uniqueSelector + '-chart-clip)',
    cx: function cx(d) {
      return scaleLinear(d.x);
    },
    cy: function cy(d) {
      return scaleLinearY(d.donors);
    },
    r: theme.mutationRadius,
    fill: function fill(d) {
      return getMutationColor ? getMutationColor(d) : 'steelblue';
    }
  }).on('mouseover', function (d) {
    if (!animating) {
      if (onMutationMouseover) {
        onMutationMouseover(d, d3.event);
      }
    }
  }).on('mouseout', function (d) {
    if (!animating) {
      d3.select('.tooltip').style('left', '-9999px');
      if (onMutationMouseout) onMutationMouseout(d, d3.event);
    }
  }).on('click', function (d) {
    return onMutationClick(d, d3.event);
  });

  var selectedMutation = data.mutations.filter(function (d) {
    return d.id === mutationId;
  }).map(function (d) {
    return Object.assign({}, d, { size: theme.mutationRadius * 3 });
  });

  chart.append('g').selectAll('rect').data(selectedMutation).enter().append('rect').attrs({
    class: 'selected-mutation-box',
    x: function x(d) {
      return scaleLinear(d.x) - d.size / 2;
    },
    y: function y(d) {
      return scaleLinearY(d.donors) - d.size / 2;
    },
    width: function width(d) {
      return d.size;
    },
    height: function height(d) {
      return d.size;
    },
    fill: 'none',
    stroke: 'rgb(251, 94, 45)',
    'stroke-width': 2
  }).on('mouseover', function (d) {
    if (!animating) {
      if (onMutationMouseover) {
        onMutationMouseover(d, d3.event);
      }
    }
  }).on('mouseout', function (d) {
    if (!animating) {
      d3.select('.tooltip').style('left', '-9999px');
      if (onMutationMouseout) onMutationMouseout(d, d3.event);
    }
  }).on('click', function (d) {
    return onMutationClick(d, d3.event);
  });

  data.mutations.forEach(function (d) {
    // Mutation lines on minimap

    chart.append('line').attrs({
      class: 'mutation-line-' + d.id,
      x1: d.x * scale + yAxisOffset,
      y1: height - xAxisOffset + proteinHeight + 80,
      x2: d.x * scale + yAxisOffset + halfPixel,
      y2: Math.max(height - xAxisOffset + proteinHeight - d.donors * 2 + 60, height - xAxisOffset + proteinHeight + 40),
      stroke: theme.black,
      'pointer-events': 'none'
    });
  });
};

var updateMutations = function updateMutations(_ref2) {
  var d3Root = _ref2.d3Root,
      checked = _ref2.checked,
      mutationClass = _ref2.mutationClass,
      type = _ref2.type,
      data = _ref2.data;

  var selectedMutations = mutationClass ? data.mutations.filter(function (x) {
    return x[mutationClass] === type;
  }) : data.mutations.slice();

  if (!checked) {
    selectedMutations.forEach(function (d) {
      d3Root.select('.mutation-line-' + d.id).attr('opacity', 0);
      d3Root.selectAll('.mutation-circle-' + d.id).attr('opacity', 0);
    });
  } else {
    selectedMutations.forEach(function (d) {
      d3Root.select('.mutation-line-' + d.id).attr('opacity', 1);
      d3Root.selectAll('.mutation-circle-' + d.id).attr('opacity', 1);
    });
  }
};

export { setupMutations, updateMutations };