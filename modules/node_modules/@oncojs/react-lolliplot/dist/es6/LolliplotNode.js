import React from 'react';
import invariant from 'invariant';
import ReactFauxDOM from 'react-faux-dom';
import attrs from './attrs';
import { dim, halfPixel } from './spatial';
import setupFilters from './filters';
import setupMinimap from './minimap';
import setupProteins from './proteins';
import { setupMutations } from './mutations';
import setupTicks from './ticks';
import theme from './theme';
import groupByType from './groupByType';
import uuid from './uuid';

/*----------------------------------------------------------------------------*/

var proteinLolliplot = function proteinLolliplot() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      d3 = _ref.d3,
      data = _ref.data,
      height = _ref.height,
      width = _ref.width,
      _ref$domainWidth = _ref.domainWidth,
      domainWidth = _ref$domainWidth === undefined ? 500 : _ref$domainWidth,
      _ref$mutationId = _ref.mutationId,
      mutationId = _ref$mutationId === undefined ? '' : _ref$mutationId,
      _ref$yAxisOffset = _ref.yAxisOffset,
      yAxisOffset = _ref$yAxisOffset === undefined ? 45 : _ref$yAxisOffset,
      _ref$xAxisOffset = _ref.xAxisOffset,
      xAxisOffset = _ref$xAxisOffset === undefined ? 200 : _ref$xAxisOffset,
      _ref$proteinHeight = _ref.proteinHeight,
      proteinHeight = _ref$proteinHeight === undefined ? 75 : _ref$proteinHeight,
      _ref$numXTicks = _ref.numXTicks,
      numXTicks = _ref$numXTicks === undefined ? 12 : _ref$numXTicks,
      _ref$numYTicks = _ref.numYTicks,
      numYTicks = _ref$numYTicks === undefined ? 15 : _ref$numYTicks,
      _ref$proteinDb = _ref.proteinDb,
      proteinDb = _ref$proteinDb === undefined ? 'pfam' : _ref$proteinDb,
      _ref$onMutationClick = _ref.onMutationClick,
      onMutationClick = _ref$onMutationClick === undefined ? function () {} : _ref$onMutationClick,
      _ref$onMutationMouseo = _ref.onMutationMouseover,
      onMutationMouseover = _ref$onMutationMouseo === undefined ? function () {} : _ref$onMutationMouseo,
      _ref$onMutationMouseo2 = _ref.onMutationMouseout,
      onMutationMouseout = _ref$onMutationMouseo2 === undefined ? function () {} : _ref$onMutationMouseo2,
      _ref$onProteinClick = _ref.onProteinClick,
      onProteinClick = _ref$onProteinClick === undefined ? function () {} : _ref$onProteinClick,
      _ref$onProteinMouseov = _ref.onProteinMouseover,
      onProteinMouseover = _ref$onProteinMouseov === undefined ? function () {} : _ref$onProteinMouseov,
      _ref$onProteinMouseou = _ref.onProteinMouseout,
      onProteinMouseout = _ref$onProteinMouseou === undefined ? function () {} : _ref$onProteinMouseou,
      getMutationColor = _ref.getMutationColor,
      animating = _ref.animating,
      min = _ref.min,
      max = _ref.max,
      dragging = _ref.dragging,
      draggingMinimap = _ref.draggingMinimap,
      sliding = _ref.sliding,
      _update = _ref._update,
      update = _ref.update,
      offsetX = _ref.offsetX,
      zoomStart = _ref.zoomStart,
      proteinMouseover = _ref.proteinMouseover,
      slideStartMin = _ref.slideStartMin,
      slideStartMax = _ref.slideStartMax,
      slideStart = _ref.slideStart;

  invariant(d3, 'You must pass in the d3 library, either v3 || v4');

  d3.selection.prototype.attrs = attrs;
  d3.scaleOrdinal = d3.scaleOrdinal || d3.scale.ordinal;
  d3.scaleLinear = d3.scaleLinear || d3.scale.linear;

  // Similar to a React target element
  var root = ReactFauxDOM.createElement('div');

  invariant(root, 'Must provide an element or selector!');

  width = width || root.clientWidth;
  height = height || root.clientHeight;

  var uniqueSelector = uuid();
  var xAxisLength = width - yAxisOffset;
  var scale = xAxisLength / domainWidth;

  var visibleMutations = data.mutations.filter(function (d) {
    return d.x > min && d.x < max;
  });

  var maxDonors = Math.max.apply(Math, visibleMutations.map(function (x) {
    return x.donors;
  }));

  var highestValue = Math.max(10, maxDonors);

  var scaleLinearY = d3.scaleLinear().domain([0, highestValue]).range([height - xAxisOffset, 15]);

  var updateTargetChartZoom = function updateTargetChartZoom(_ref2) {
    var zoomX = _ref2.zoomX,
        zoomWidth = _ref2.zoomWidth,
        offsetX = _ref2.offsetX,
        difference = _ref2.difference;

    var draggingLeft = difference < 0;

    var scale = d3.scaleLinear().domain([0, xAxisLength]).range([min, max]);

    var targetMin = Math.max(0, draggingLeft ? scale(offsetX - yAxisOffset) : scale(zoomX - yAxisOffset));

    var targetMax = Math.min(domainWidth, draggingLeft ? scale(offsetX + zoomWidth - yAxisOffset) : scale(offsetX - yAxisOffset));

    return [targetMin, targetMax];
  };

  var updateTargetMinimapZoom = function updateTargetMinimapZoom(_ref3) {
    var zoomX = _ref3.zoomX,
        zoomWidth = _ref3.zoomWidth,
        offsetX = _ref3.offsetX,
        difference = _ref3.difference;

    var draggingLeft = difference < 0;

    var targetMin = Math.max(0, draggingLeft ? (offsetX - yAxisOffset) / scale : (zoomX - yAxisOffset) / scale);

    var targetMax = Math.min(domainWidth, draggingLeft ? (offsetX - yAxisOffset + zoomWidth) / scale : (offsetX - yAxisOffset) / scale);

    return [targetMin, targetMax];
  };

  // Main Chart

  var d3Root = d3.select(root).style('position', 'relative');

  var svg = d3Root.append('svg').attrs(Object.assign({
    class: 'chart'
  }, dim(width, height))).on('mousemove', function () {
    if (sliding) {
      update({
        min: Math.max(0, slideStartMin + Math.round((d3.event.offsetX - slideStart) / scale)),
        max: Math.min(domainWidth, slideStartMax + Math.round((d3.event.offsetX - slideStart) / scale))
      });
    }
  }).on('mouseup', function () {
    if (sliding) {
      _update({ sliding: false });
    }

    if (dragging || draggingMinimap) {

      var difference = offsetX - zoomStart;

      // do not zoom if insignificant dragging distance
      if (Math.abs(difference) < 5) {
        _update({ dragging: false, draggingMinimap: false });
        return;
      }

      if (dragging) {
        var _updateTargetChartZoo = updateTargetChartZoom({
          zoomX: difference < 0 ? offsetX : zoomStart,
          zoomWidth: Math.abs(difference),
          offsetX: offsetX,
          difference: difference
        }),
            _targetMin = _updateTargetChartZoo[0],
            _targetMax = _updateTargetChartZoo[1];

        update({
          min: _targetMin,
          max: _targetMax
        });
      }

      if (draggingMinimap) {
        var _updateTargetMinimapZ = updateTargetMinimapZoom({
          zoomX: difference < 0 ? offsetX : zoomStart,
          zoomWidth: Math.abs(difference),
          offsetX: offsetX,
          difference: difference
        }),
            _targetMin2 = _updateTargetMinimapZ[0],
            _targetMax2 = _updateTargetMinimapZ[1];

        update({
          min: _targetMin2,
          max: _targetMax2
        });
      }

      _update({
        dragging: false,
        draggingMinimap: false
      });
    }
  });

  var defs = svg.append('defs');

  setupFilters(defs);

  // Chart clipPath

  defs.append('clipPath').attr('id', uniqueSelector + '-chart-clip').append('rect').attrs(Object.assign({
    x: yAxisOffset,
    y: 0
  }, dim(xAxisLength, height - xAxisOffset + proteinHeight)));

  // Chart zoom area

  var chart = d3Root.select('.chart');

  chart.append('rect').attrs({
    class: 'chart-zoom-area',
    x: yAxisOffset,
    y: halfPixel,
    width: xAxisLength,
    height: height - xAxisOffset - halfPixel,
    fill: 'white',
    stroke: 'rgb(181, 181, 181)',
    'stroke-width': 1
  }).on('mousedown', function () {
    _update({
      dragging: true,
      zoomStart: d3.event.offsetX,
      offsetX: d3.event.offsetX
    });
  }).on('mousemove', function () {
    _update({
      offsetX: d3.event.offsetX
    });
  });

  // yAxis

  svg.append('g').append('line').attrs({
    class: 'yAxis',
    x1: yAxisOffset,
    y1: 0,
    x2: yAxisOffset,
    y2: height - xAxisOffset,
    stroke: theme.black
  });

  // yAxis label

  chart.append('text').text('# of Cases').attrs({
    x: 5,
    y: (height - xAxisOffset) / 2,
    'font-size': '11px',
    transform: 'rotate(270, 10, 124)'
  });

  // xAxis

  svg.append('g').append('line').attrs({
    class: 'xAxis',
    x1: yAxisOffset,
    y1: height - xAxisOffset,
    x2: width,
    y2: height - xAxisOffset,
    stroke: theme.black
  });

  // Backbone

  svg.append('g').append('rect').attrs({
    class: 'xAxisBottom',
    x: yAxisOffset,
    y: height - xAxisOffset + (proteinHeight - 28) + halfPixel,
    width: width,
    height: 10,
    fill: '#d0d0d0'
  });

  setupMinimap({
    svg: svg,
    width: width,
    height: height,
    yAxisOffset: yAxisOffset,
    xAxisOffset: xAxisOffset,
    xAxisLength: xAxisLength,
    proteinHeight: proteinHeight,
    domainWidth: domainWidth,
    uniqueSelector: uniqueSelector,
    min: min,
    max: max,
    scale: scale,
    d3: d3,
    _update: _update
  });

  chart.append('text').text(proteinDb).attrs({
    x: 5,
    y: height - xAxisOffset + 58,
    'font-size': '11px'
  });

  if (dragging) {
    var difference = offsetX - zoomStart;

    svg.append('g').append('rect').attrs({
      'clip-path': 'url(#' + uniqueSelector + '-clip)',
      x: difference < 0 ? offsetX : zoomStart,
      y: 0,
      width: Math.abs(difference),
      height: height - xAxisOffset,
      fill: 'rgba(214, 214, 214, 0.51)',
      cursor: 'text',
      'pointer-events': 'none'
    });
  }

  if (draggingMinimap) {
    var _difference = offsetX - zoomStart;

    svg.append('g').append('rect').attrs({
      'clip-path': 'url(#' + uniqueSelector + '-clip)',
      x: _difference < 0 ? offsetX : zoomStart,
      y: height - xAxisOffset + proteinHeight + 40,
      width: Math.abs(_difference),
      height: 50,
      fill: 'rgba(83, 215, 88, 0.51)',
      cursor: 'text',
      'pointer-events': 'none'
    });
  }

  setupMutations({
    d3: d3,
    chart: chart,
    scaleLinearY: scaleLinearY,
    onMutationClick: onMutationClick,
    onMutationMouseover: onMutationMouseover,
    onMutationMouseout: onMutationMouseout,
    getMutationColor: getMutationColor,
    mutationId: mutationId,
    data: data,
    yAxisOffset: yAxisOffset,
    xAxisOffset: xAxisOffset,
    height: height,
    proteinHeight: proteinHeight,
    scale: scale,
    maxDonors: maxDonors,
    animating: animating,
    uniqueSelector: uniqueSelector,
    min: min,
    max: max,
    width: width
  });

  var minimapWidth = Math.max(1, (max - min) * scale - 1);

  svg.append('g').append('rect').attrs(Object.assign({
    class: 'minimap-slide-target',
    x: min * scale + yAxisOffset + halfPixel + minimapWidth - 20,
    y: height - xAxisOffset + proteinHeight + 45
  }, dim(15, 15), {
    fill: 'rgb(255, 255, 255)',
    stroke: 'rgb(57, 57, 57)',
    cursor: 'move'
  })).on('mousedown', function () {
    _update({
      sliding: true,
      slideStart: d3.event.offsetX,
      slideStartMin: min,
      slideStartMax: max
    });
  });

  svg.append('text').text('\u27FA').attrs({
    class: 'minimap-slide-target-arrow',
    x: min * scale + yAxisOffset + halfPixel + minimapWidth - 19,
    y: height - xAxisOffset + proteinHeight + 56,
    'font-size': '11px',
    'pointer-events': 'none'
  });

  setupProteins({
    d3: d3,
    chart: chart,
    defs: defs,
    onProteinClick: onProteinClick,
    onProteinMouseover: onProteinMouseover,
    onProteinMouseout: onProteinMouseout,
    data: data,
    scale: scale,
    yAxisOffset: yAxisOffset,
    xAxisOffset: xAxisOffset,
    proteinHeight: proteinHeight,
    height: height,
    uniqueSelector: uniqueSelector,
    min: min,
    max: max,
    width: width,
    domainWidth: domainWidth,
    proteinMouseover: proteinMouseover
  });

  setupTicks({
    d3Root: d3Root,
    svg: svg,
    numYTicks: numYTicks,
    numXTicks: numXTicks,
    maxDonors: maxDonors,
    scaleLinearY: scaleLinearY,
    xAxisOffset: xAxisOffset,
    yAxisOffset: yAxisOffset,
    domainWidth: domainWidth,
    scale: scale,
    height: height,
    min: min,
    max: max,
    highestValue: highestValue
  });

  return root.toReact();
};

/*----------------------------------------------------------------------------*/

export default proteinLolliplot;