// @flow
import * as d3 from 'd3'
import { dim, halfPixel } from './spatial'
import setupStore from './store'
// import setupFilters from './filters'
// import setupMinimap from './minimap'
// import setupProteins from './proteins'
// import { setupMutations, updateMutations } from './mutations'
// import { setupStats, updateStats } from './stats'
// import setupTicks from './ticks'
// import setupZoomHandlers from './zoom'
import theme from './theme'
import groupByType from './groupByType'
// import animator from './animator'
import { shouldAnimationFinish, calculateNextCoordinate } from './animation'
// import { updateStats } from './stats'

let totalAnimationIterations = 30

/*----------------------------------------------------------------------------*/

let minMax = (a, n) => ({
  cMin: a.cMin < n.x ? a.cMin : n.x,
  cMax: a.cMax > n.x ? a.cMax : n.x,
})

type TProteinLolliplotArgs = {
  onMutationClick: Function,
  onMutationMouseover: ?Function,
  onMutationMouseout: ?Function,
  onProteinMouseover: ?Function,
  onProteinMouseout: ?Function,
  data: Object,
  selector: string,
  element: Object,
  height: number,
  width: number,
  domainWidth: number,
  hideStats: bool,
  selectedMutationClass: string,
  mutationId: string,
  yAxisOffset: number,
  xAxisOffset: number,
}
type TProteinLolliplot = (args: TProteinLolliplotArgs) => Object
let proteinLolliplot: TProteinLolliplot = ({
  // onMutationClick,
  // onMutationMouseover,
  // onMutationMouseout,
  // onProteinMouseover,
  // onProteinMouseout,
  data,
  selector,
  element,
  height,
  width,
  domainWidth,
  mutationId,
  yAxisOffset,
  xAxisOffset,
} = {}) => {

  data.mutations.sort((a, b) => a.x - b.x)

  let threshold = 15

  // cluster

  let root = element || document.querySelector(selector)

  if (!root) throw `Must provide an element or selector!`

  let container = document.querySelector(`.inner`)
  let ctx = root.getContext(`2d`)

  width = width || container.clientWidth
  height = height || container.clientHeight

  root.width = width
  root.height = height

  domainWidth = domainWidth || 500
  yAxisOffset = yAxisOffset || 45
  xAxisOffset = xAxisOffset || 200

  let generation = 0

  let proteinHeight = 40

  let store = setupStore({ domainWidth })

  let maxDonors = Math.max(...data.mutations.map(x => x.donors))

  let scaleLinearY = d3.scaleLinear()
    .domain([0, Math.round(maxDonors + 5)])
    .range([height - xAxisOffset, 0])

  let scaleLinear = d3.scaleLinear()
    .domain([0, domainWidth])
    .range([yAxisOffset, width])

  let clusters = {}

  let draw = () => {
    root.width = root.width

    // yAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, 0)
    ctx.lineTo(yAxisOffset, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // xAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset)
    ctx.lineTo(width, height - xAxisOffset)
    ctx.stroke()

    // Vertical line on the right of the protein bar

    ctx.beginPath()
    ctx.moveTo(width, height - xAxisOffset)
    ctx.lineTo(width, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // Horizontal line under protein bar

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.lineTo(width, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.stroke()

    ctx.strokeStyle = `rgba(0, 0, 0, 0.2)`

    let {
      targetMin,
      targetMax,
      startMin,
      startMax,
      currentAnimationIteration,
      domain: lastDomain
    } = store.getState()

    let min = calculateNextCoordinate({
      start: startMin, target: targetMin, currentAnimationIteration, totalAnimationIterations,
    })

    let max = calculateNextCoordinate({
      start: startMax, target: targetMax, currentAnimationIteration, totalAnimationIterations,
    })

    let domain = max - min

    let { generating } = store.getState()

    if (!domain !== lastDomain && !generating) {
      console.log('not generating, domain changed')
      requestIdleCallback(clusterize)
    }

    if (!domain !== lastDomain && generating) {
      console.log('generating, domain changed')
    }

    store.update({ min, max, domain, currentAnimationIteration: currentAnimationIteration + 1 })

    scaleLinear = d3.scaleLinear()
      .domain([min, max])
      .range([yAxisOffset, width])

    if (shouldAnimationFinish({ startMin, startMax, targetMin, targetMax, min, max })) {
      store.update({
        animating: false,
        startMin: min,
        startMax: max,
        currentAnimationIteration: 0,
      })
    }

    Object.keys(clusters).forEach(y => {
      for (let i = 0; i < clusters[y].length; i++) {
        if (clusters[y][i].length > 1) {

          //draw a cluster
          let { cMin, cMax } = clusters[y][i].reduce(minMax, {})

          cMin = ~~scaleLinear(cMin)
          cMax = ~~scaleLinear(cMax)

          if (cMax > yAxisOffset && cMin < width) {
            ctx.beginPath()
            ctx.fillStyle = `red`
            ctx.arc(Math.max(yAxisOffset, cMin), y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.arc(cMax, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.rect(
              Math.max(yAxisOffset, cMin),
              y - theme.mutationRadius,
              cMax - cMin,
              theme.mutationRadius * 2
            )
            ctx.fill()
          }
        } else {
          // draw a circle
          let d = clusters[y][i][0]
          let x = ~~scaleLinear(d.x)
          if (x > yAxisOffset && x < width) {
            ctx.fillStyle = `red`
            ctx.beginPath()
            ctx.arc(x, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.fill()
          }
        }
      }
    })

    if (store.getState().animating) window.requestAnimationFrame(draw)
    else {
      console.log('last time')
      requestIdleCallback(clusterize)
    }
  }

  let draw2 = () => {
    root.width = root.width

    console.log(clusters.generation)

    // yAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, 0)
    ctx.lineTo(yAxisOffset, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // xAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset)
    ctx.lineTo(width, height - xAxisOffset)
    ctx.stroke()

    // Vertical line on the right of the protein bar

    ctx.beginPath()
    ctx.moveTo(width, height - xAxisOffset)
    ctx.lineTo(width, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // Horizontal line under protein bar

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.lineTo(width, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.stroke()

    ctx.strokeStyle = `rgba(0, 0, 0, 0.2)`

    let {
      min, max,
    } = store.getState()

    scaleLinear = d3.scaleLinear()
      .domain([min, max])
      .range([yAxisOffset, width])

    Object.keys(clusters).forEach(y => {
      for (let i = 0; i < clusters[y].length; i++) {
        if (clusters[y][i].length > 1) {

          //draw a cluster
          let { cMin, cMax } = clusters[y][i].reduce(minMax, {})

          cMin = ~~scaleLinear(cMin)
          cMax = ~~scaleLinear(cMax)

          if (cMax > yAxisOffset && cMin < width) {
            ctx.beginPath()
            ctx.fillStyle = `red`
            ctx.arc(Math.max(yAxisOffset, cMin), y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.arc(cMax, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.rect(
              Math.max(yAxisOffset, cMin),
              y - theme.mutationRadius,
              cMax - cMin,
              theme.mutationRadius * 2
            )
            ctx.fill()
          }
        } else {
          // draw a circle
          let d = clusters[y][i][0]
          let x = ~~scaleLinear(d.x)
          if (x > yAxisOffset && x < width) {
            ctx.fillStyle = `red`
            ctx.beginPath()
            ctx.arc(x, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.fill()
          }
        }
      }
    })
  }

  let reset = () => {
    store.update({
      animating: true,
      targetMin: 0,
      targetMax: domainWidth,
      consequenceFilters: [],
      impactFilters: [],
    })

    requestIdleCallback(clusterize)
    draw()
  }

  let zoom = () => {
    store.update({
      animating: true,
      targetMin: 200,
      targetMax: 300,
      consequenceFilters: [],
      impactFilters: [],
    })

    requestIdleCallback(clusterize)
    draw()
  }

  let resetBtn = document.querySelector(`#reset`)
  if (resetBtn) resetBtn.addEventListener(`click`, reset)

  let zoomBtn = document.querySelector(`#zoom`)
  if (zoomBtn) zoomBtn.addEventListener(`click`, zoom)

  window.addEventListener(`resize`, () => {
    width = width || container.clientWidth
    height = height || container.clientHeight

    root.width = width
    root.height = height
    draw()
  })

  let fiber = {
    i: 0,
    clusters: {},
  }

  let clusterize = d => {
    store.update({ generating: true })

    let {
      targetMin,
      targetMax,
      startMin,
      startMax,
      currentAnimationIteration,
    } = store.getState()

    let min = calculateNextCoordinate({
      start: startMin, target: targetMin, currentAnimationIteration, totalAnimationIterations,
    })

    let max = calculateNextCoordinate({
      start: startMax, target: targetMax, currentAnimationIteration, totalAnimationIterations,
    })

    scaleLinear = d3.scaleLinear()
      .domain([min, max])
      .range([yAxisOffset, width])

    console.log('top of cluster', fiber.i)

    outer:
    while (d.timeRemaining() && fiber.i < data.mutations.length) {
      let d = data.mutations[fiber.i]
      let y = ~~scaleLinearY(d.donors)

      if (fiber.clusters[y]) {
       // loop through the inner lists
        for (let i = 0; i < fiber.clusters[y].length; i++) {
         // if the inner list only has one item
          if (fiber.clusters[y][i].length === 1) {
           // check if the next value is within the threshold
            if (scaleLinear(d.x) - scaleLinear(fiber.clusters[y][i][0].x) < threshold) {
             // if so, append it to the inner list
              let na = [ fiber.clusters[y][i][0], d ]
             // and add it to the outer list
              fiber.clusters = {
                ...fiber.clusters,
                [y]: [
                  ...fiber.clusters[y].slice(0, i),
                  na,
                  ...fiber.clusters[y].slice(i + 1, Infinity),
                ],
              }
              fiber.i++
              continue outer
            }
           // if not, append the single list item to the outer list
            fiber.clusters = {
              ...fiber.clusters,
              [y]: [...fiber.clusters[y], [d]],
            }
            fiber.i++
            continue outer
         // if the inner list has more than one item
          } else if (fiber.clusters[y][i].length > 1) {
           // loop through the inner list to get the min and max values
            let { cMin, cMax } = fiber.clusters[y][i].reduce(minMax, {})
             // if the next value is within the min or max thresholds
            if (
             Math.abs(scaleLinear(d.x) - scaleLinear(cMax)) < threshold ||
             Math.abs(scaleLinear(cMin) - scaleLinear(d.x)) < threshold
           ) {
             // append it to the inner list
              let na = [ ...fiber.clusters[y][i], d ]
              fiber.clusters = {
                ...fiber.clusters,
                [y]: [
                  ...fiber.clusters[y].slice(0, i),
                  na,
                  ...fiber.clusters[y].slice(i + 1, Infinity),
                ],
              }
              fiber.i++
              continue outer
            }
          }
        }

        fiber.clusters = {
          ...fiber.clusters,
          [y]: [...fiber.clusters[y], [d]],
        }
        fiber.i++
        continue
      }

      fiber.clusters = {
        ...fiber.clusters,
        [y]: [[d]],
      }
      fiber.i++
    }

    if (fiber.i < data.mutations.length) {
      console.log('inside clusterize', fiber.i)
      requestIdleCallback(clusterize)
    } else {
      store.update({ generating: false })
      clusters = Object.assign({}, { generation: generation++ }, fiber.clusters)

      fiber = {
        i: 0,
        clusters: {},
      }

      draw2()
    }
  }

  requestIdleCallback(clusterize)
}


/*----------------------------------------------------------------------------*/

export default proteinLolliplot
