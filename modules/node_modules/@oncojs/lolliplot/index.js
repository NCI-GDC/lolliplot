// @flow
import * as d3 from 'd3'
import { dim, halfPixel } from './spatial'
import setupStore from './store'
// import setupFilters from './filters'
// import setupMinimap from './minimap'
// import setupProteins from './proteins'
// import { setupMutations, updateMutations } from './mutations'
// import { setupStats, updateStats } from './stats'
// import setupTicks from './ticks'
// import setupZoomHandlers from './zoom'
import theme from './theme'
import groupByType from './groupByType'
// import animator from './animator'
import { shouldAnimationFinish, calculateNextCoordinate } from './animation'
// import { updateStats } from './stats'

let totalAnimationIterations = 30

/*----------------------------------------------------------------------------*/

let minMax = (a, n) => ({
  cMin: a.cMin < n.x ? a.cMin : n.x,
  cMax: a.cMax > n.x ? a.cMax : n.x,
})

type TProteinLolliplotArgs = {
  onMutationClick: Function,
  onMutationMouseover: ?Function,
  onMutationMouseout: ?Function,
  onProteinMouseover: ?Function,
  onProteinMouseout: ?Function,
  data: Object,
  selector: string,
  element: Object,
  height: number,
  width: number,
  domainWidth: number,
  hideStats: bool,
  selectedMutationClass: string,
  mutationId: string,
  yAxisOffset: number,
  xAxisOffset: number,
}
type TProteinLolliplot = (args: TProteinLolliplotArgs) => Object
let proteinLolliplot: TProteinLolliplot = ({
  // onMutationClick,
  // onMutationMouseover,
  // onMutationMouseout,
  // onProteinMouseover,
  // onProteinMouseout,
  data,
  selector,
  element,
  height,
  width,
  domainWidth,
  mutationId,
  yAxisOffset,
  xAxisOffset,
} = {}) => {

  data.mutations.sort((a, b) => a.x - b.x)

  let threshold = 100

  // cluster

  let root = element || document.querySelector(selector)

  if (!root) throw `Must provide an element or selector!`

  let container = document.querySelector(`.inner`)
  let ctx = root.getContext(`2d`)

  width = width || container.clientWidth
  height = height || container.clientHeight

  root.width = width
  root.height = height

  domainWidth = domainWidth || 500
  yAxisOffset = yAxisOffset || 45
  xAxisOffset = xAxisOffset || 200

  let proteinHeight = 40

  let store = setupStore({ domainWidth })

  let maxDonors = Math.max(...data.mutations.map(x => x.donors))

  let scaleLinearY = d3.scaleLinear()
    .domain([0, Math.round(maxDonors + 5)])
    .range([height - xAxisOffset, 0])

  let draw = () => {
    root.width = root.width

    // yAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, 0)
    ctx.lineTo(yAxisOffset, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // xAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset)
    ctx.lineTo(width, height - xAxisOffset)
    ctx.stroke()

    // Vertical line on the right of the protein bar

    ctx.beginPath()
    ctx.moveTo(width, height - xAxisOffset)
    ctx.lineTo(width, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // Horizontal line under protein bar

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.lineTo(width, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.stroke()

    ctx.strokeStyle = `rgba(0, 0, 0, 0.2)`

    let {
      targetMin,
      targetMax,
      startMin,
      startMax,
      currentAnimationIteration,
    } = store.getState()

    let min = calculateNextCoordinate({
      start: startMin, target: targetMin, currentAnimationIteration, totalAnimationIterations,
    })

    let max = calculateNextCoordinate({
      start: startMax, target: targetMax, currentAnimationIteration, totalAnimationIterations,
    })

    let domain = max - min

    store.update({ min, max, domain, currentAnimationIteration: currentAnimationIteration + 1 })

    if (shouldAnimationFinish({ startMin, startMax, targetMin, targetMax, min, max })) {
      store.update({
        animating: false,
        startMin: min,
        startMax: max,
        currentAnimationIteration: 0,
      })
    }

    let scaleLinear = d3.scaleLinear()
      .domain([min, max])
      .range([yAxisOffset, width])

    let clusters = data.mutations.reduce((a, d) => {
      let y = ~~scaleLinearY(d.donors)

      // We've seen this y value before
      if (a[y]) {
        // loop through the inner lists
        for (let i = 0; i < a[y].length; i ++) {
          // if the inner list only has one item
          if (a[y][i].length === 1) {
            // check if the next value is within the threshold
            if (scaleLinear(d.x) - scaleLinear(a[y][i][0].x) < threshold) {
              // if so, append it to the inner list
              let na = [ a[y][i][0], d ]
              // and return the new accumulator
              return {
                ...a,
                [y]: [...a[y].slice(0, i), na, ...a[y].slice(i + 1, Infinity)],
              }
            }
            // if not, append the single list item to the outer list
            // and return the accumulator
            return {
              ...a,
              [y]: [...a[y], [d]],
            }
          // if the inner list has more than one item
          } else if (a[y][i].length > 1) {
            // loop through the inner list to get the min and max values
            for (let j = 0; j < a[y][i].length; j++) {
              let { cMin, cMax } = a[y][i].reduce(minMax)
              // if the next value is within the min or max thresholds
              if (Math.abs(
                scaleLinear(d.x) - scaleLinear(cMax)) < threshold ||
                Math.abs(scaleLinear(cMin) - scaleLinear(d.x)) < threshold)
                {
                // append it to the inner list
                let na = [ a[y][i][j], d ]
                return {
                  ...a,
                  [y]: [...a[y].slice(0, i), na, ...a[y].slice(i + 1, Infinity)],
                }
              }
              // if not, append the single list item to the outer list
              // and return the accumulator
              return {
                ...a,
                [y]: [...a[y], [d]],
              }
            }
          }
        }
      }

      return {
        ...a,
        [y]: [[d]],
      }
    }, {})

    Object.keys(clusters).forEach(y => {
      for (let i = 0; i < clusters[y].length; i++) {
        if (clusters[y][i].length > 1) {

          // console.log(clusters[y][i])
          //draw a cluster
          let { cMin, cMax } = clusters[y][i].reduce(minMax)

          console.log(1, cMin)

          cMin = ~~scaleLinear(cMin)
          cMax = ~~scaleLinear(cMax)

          console.log(2, cMin)

          if (cMax > yAxisOffset && cMin < width) {
            ctx.beginPath()
            ctx.fillStyle = `blue`
            ctx.arc(cMin, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.arc(cMax, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.rect(cMin, y - theme.mutationRadius, cMax - cMin, theme.mutationRadius * 2)
            ctx.fill()
          }
        } else {
          // draw a circle
          let d = clusters[y][i][0]
          let x = ~~scaleLinear(d.x)
          if (x > yAxisOffset && x < width) {
            ctx.fillStyle = `red`
            ctx.beginPath()
            ctx.arc(x, y, theme.mutationRadius, 0, 2 * Math.PI)
            ctx.fill()
          }
        }
      }

    })

    if (store.getState().animating) window.requestAnimationFrame(draw)
  }

  let reset = () => {
    store.update({
      animating: true,
      targetMin: 0,
      targetMax: domainWidth,
      consequenceFilters: [],
      impactFilters: [],
    })

    draw()
  }

  let zoom = () => {
    store.update({
      animating: true,
      targetMin: 250,
      targetMax: 350,
      consequenceFilters: [],
      impactFilters: [],
    })

    draw()
  }

  let resetBtn = document.querySelector(`#reset`)
  if (resetBtn) resetBtn.addEventListener(`click`, reset)

  let zoomBtn = document.querySelector(`#zoom`)
  if (zoomBtn) zoomBtn.addEventListener(`click`, zoom)

  draw()

  window.addEventListener(`resize`, () => {
    width = width || container.clientWidth
    height = height || container.clientHeight

    root.width = width
    root.height = height
    draw()
  })
}


/*----------------------------------------------------------------------------*/

export default proteinLolliplot
