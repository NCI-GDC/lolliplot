// @flow
import * as d3 from 'd3'
import { dim, halfPixel } from './spatial'
import setupStore from './store'
// import setupFilters from './filters'
// import setupMinimap from './minimap'
// import setupProteins from './proteins'
// import { setupMutations, updateMutations } from './mutations'
// import { setupStats, updateStats } from './stats'
// import setupTicks from './ticks'
// import setupZoomHandlers from './zoom'
import theme from './theme'
import groupByType from './groupByType'
// import animator from './animator'
import { shouldAnimationFinish, calculateNextCoordinate } from './animation'
// import { updateStats } from './stats'

let totalAnimationIterations = 30

/*----------------------------------------------------------------------------*/


type TProteinLolliplotArgs = {
  onMutationClick: Function,
  onMutationMouseover: ?Function,
  onMutationMouseout: ?Function,
  onProteinMouseover: ?Function,
  onProteinMouseout: ?Function,
  data: Object,
  selector: string,
  element: Object,
  height: number,
  width: number,
  domainWidth: number,
  hideStats: bool,
  selectedMutationClass: string,
  mutationId: string,
  yAxisOffset: number,
  xAxisOffset: number,
}
type TProteinLolliplot = (args: TProteinLolliplotArgs) => Object
let proteinLolliplot: TProteinLolliplot = ({
  // onMutationClick,
  // onMutationMouseover,
  // onMutationMouseout,
  // onProteinMouseover,
  // onProteinMouseout,
  data,
  selector,
  element,
  height,
  width,
  domainWidth,
  hideStats,
  // selectedMutationClass,
  // mutationId,
  yAxisOffset,
  xAxisOffset,
} = {}) => {

  let root = element || document.querySelector(selector)

  if (!root) throw `Must provide an element or selector!`

  let container = document.querySelector(`.inner`)

  console.dir(container)

  let ctx = root.getContext(`2d`)

  width = width || container.clientWidth
  height = height || container.clientHeight

  root.width = width
  root.height = height

  domainWidth = domainWidth || 500
  // selectedMutationClass = selectedMutationClass || `Consequence`

  yAxisOffset = yAxisOffset || 45
  xAxisOffset = xAxisOffset || 200

  let statsBoxWidth = hideStats ? 0 : 250
  let proteinHeight = 40

  let xAxisLength = width - yAxisOffset - statsBoxWidth
  let scale = xAxisLength / domainWidth

  let numXTicks = 12
  // let numYTicks = 15

  let store = setupStore({ domainWidth })

  let consequences = groupByType(`consequence`, data.mutations)
  let impacts = groupByType(`impact`, data.mutations)

  let colorScale = d3.scaleOrdinal(d3.schemeCategory20).domain(d3.range(20))

  let consequenceColors = Object.keys(consequences).reduce((acc, type, i) => ({
    ...acc,
    [type]: colorScale(i * 3),
  }), {})

  let maxDonors = Math.max(...data.mutations.map(x => x.donors))

  let scaleLinearY = d3.scaleLinear()
    .domain([0, Math.round(maxDonors + 5)])
    .range([height - xAxisOffset, 0])

  // let proteinDb = `pfam` // TODO: get from data

  let draw = () => {
    root.width = root.width

    // yAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, 0)
    ctx.lineTo(yAxisOffset, height - xAxisOffset + proteinHeight)
    ctx.stroke()

    // xAxis

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset)
    ctx.lineTo(width - statsBoxWidth, height - xAxisOffset)
    ctx.stroke()

    // Vertical line on the right of the protein bar

    ctx.beginPath()
    ctx.moveTo(width - statsBoxWidth, height - xAxisOffset)
    ctx.lineTo(width - statsBoxWidth, height - xAxisOffset + proteinHeight)
    ctx.stroke()

  // Horizontal line under protein bar

    ctx.beginPath()
    ctx.moveTo(yAxisOffset, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.lineTo(width - statsBoxWidth, height - xAxisOffset + proteinHeight + halfPixel)
    ctx.stroke()

    ctx.strokeStyle = `rgba(0, 0, 0, 0.2)`

    let {
      targetMin,
      targetMax,
      startMin,
      startMax,
      currentAnimationIteration,
      consequenceFilters,
      impactFilters,
    } = store.getState()

    let min = calculateNextCoordinate({
      start: startMin, target: targetMin, currentAnimationIteration, totalAnimationIterations,
    })

    let max = calculateNextCoordinate({
      start: startMax, target: targetMax, currentAnimationIteration, totalAnimationIterations,
    })

    let domain = max - min

    store.update({ min, max, domain, currentAnimationIteration: currentAnimationIteration + 1 })

    if (shouldAnimationFinish({ startMin, startMax, targetMin, targetMax, min, max })) {
      store.update({
        animating: false,
        startMin: min,
        startMax: max,
        currentAnimationIteration: 0,
      })
    }

    let scaleLinear = d3.scaleLinear()
      .domain([min, max])
      .range([yAxisOffset, width - statsBoxWidth])

    data.mutations.forEach(d => {
      let x = ~~scaleLinear(d.x)
      let y = ~~scaleLinearY(d.donors)

      if (x > yAxisOffset && x < width - statsBoxWidth) {

        ctx.beginPath()
        ctx.moveTo(x, height - xAxisOffset)
        ctx.lineTo(x, y)
        ctx.stroke()

        ctx.fillStyle = `rgb(64, 135, 120)`
        ctx.beginPath()
        ctx.arc(
          x,
          y,
          theme.mutationRadius,
          0, 2 * Math.PI
        )
        ctx.fill()
      }
    })

    //
    // animateScaleY({
    //   data,
    //   consequenceFilters,
    //   impactFilters,
    //   min,
    //   max,
    //   mutationChartLines,
    //   mutationChartCircles,
    //   height,
    //   xAxisOffset,
    //   visibleMutations: null,
    // })
    //
    // updateStats({
    //   store,
    //   data,
    //   consequences,
    //   impacts,
    //   consequenceColors,
    //   mutationChartLines,
    //   mutationChartCircles,
    //   height,
    //   xAxisOffset,
    // })


    if (store.getState().animating) window.requestAnimationFrame(draw)
  }

  let reset = () => {
    store.update({
      animating: true,
      targetMin: 0,
      targetMax: domainWidth,
      consequenceFilters: [],
      impactFilters: [],
    })

    draw()
  }

  let zoom = () => {
    store.update({
      animating: true,
      targetMin: 250,
      targetMax: 350,
      consequenceFilters: [],
      impactFilters: [],
    })

    draw()
  }

  let resetBtn = document.querySelector(`#reset`)
  if (resetBtn) resetBtn.addEventListener(`click`, reset)

  let zoomBtn = document.querySelector(`#zoom`)
  if (zoomBtn) zoomBtn.addEventListener(`click`, zoom)

  draw()
}

/*----------------------------------------------------------------------------*/

export default proteinLolliplot
